from fastapi import (
    FastAPI,
    HTTPException,
    Path,
    Request,
    Header,
    BackgroundTasks,
    status,
    Query,
)
from grpc import Status
from starlette.middleware.sessions import SessionMiddleware
from fastapi.middleware.cors import CORSMiddleware
import os
from typing import List, Optional
import logging
from firebase_utils import db, verify_firebase_token, firestore, auth
from models import ChatRequest, ChatResponse
from tools import agent, ChatMessage, llm
from utils import (
    get_conversation_context,
    update_conversation_context,
    summarize_context,
    clean_up_old_sessions,
    merge_unauthenticated_session_to_user,
    end_session,
    generate_default_chat_name,
)
import httpx
from google.cloud import firestore
import asyncio
from typing import Dict, Any
from datetime import datetime
import time

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
app.add_middleware(
    SessionMiddleware, secret_key=os.getenv("SESSION_SECRET_KEY", "your-secret-key")
)


@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(
    request: ChatRequest,
    fastapi_request: Request,
    background_tasks: BackgroundTasks,
    authorization: str = Header(None),  # Firebase auth token
):
    logger.debug("Starting chat_endpoint")
    try:
        user_id = None
        chat_id = request.chat_id

        # Retrieve or create session_id
        session_id = fastapi_request.session.get("session_id")
        if not session_id:
            session_id = os.urandom(16).hex()
            fastapi_request.session["session_id"] = session_id
            logger.debug(f"New session created with session_id: {session_id}")
        client_ip = fastapi_request.client.host

        # Ensure chat_id is generated if not provided
        if not chat_id:
            chat_id = os.urandom(16).hex()
            logger.debug(f"Generated new chat_id: {chat_id}")

        # Reference the chat document in the chats collection
        chat_ref = db.collection("chats").document(chat_id)

        # If the chat is new, set up the chat document
        chat_doc = chat_ref.get()
        if not chat_doc.exists:
            # Generate a default name using the utility function
            default_name = generate_default_chat_name(request.message)

            chat_data = {
                "chat_id": chat_id,
                "user_ids": [user_id] if user_id else [],
                "session_ids": [session_id] if not user_id else [],
                "created_at": firestore.SERVER_TIMESTAMP,
                "last_updated": firestore.SERVER_TIMESTAMP,
                "name": default_name,  # Default name generated by LLM
            }
            chat_ref.set(chat_data)
            logger.debug(f"New chat document created with chat_id: {chat_id}")
        else:
            chat_data = chat_doc.to_dict()
            if user_id and user_id not in chat_data["user_ids"]:
                chat_ref.update({"user_ids": firestore.ArrayUnion([user_id])})
            if not user_id and session_id not in chat_data["session_ids"]:
                chat_ref.update({"session_ids": firestore.ArrayUnion([session_id])})
            # Set default name if not already set
            if "name" not in chat_data or not chat_data["name"]:
                chat_ref.update({"name": f"Chat {firestore.SERVER_TIMESTAMP}"})
            logger.debug(f"Chat document updated with chat_id: {chat_id}")
        user_agent = fastapi_request.headers.get("user-agent", "unknown")

        # Verify user authentication and get user_id if authenticated
        if authorization:
            try:
                token = authorization.split(" ")[1]
                decoded_token = verify_firebase_token(token)
                user_id = decoded_token.get("uid")

                # If chat_id is not provided, generate a new one
                if not chat_id:
                    chat_id = os.urandom(16).hex()
                    logger.debug(f"Generated new chat_id: {chat_id}")
            except IndexError:
                raise HTTPException(
                    status_code=400, detail="Invalid authorization header format"
                )
        else:
            # For anonymous users, generate a new chat_id if none is provided
            if not chat_id:
                chat_id = os.urandom(16).hex()
                logger.debug(f"Generated new chat_id for anonymous session: {chat_id}")

        # Reference the chat document in the chats collection
        chat_ref = db.collection("chats").document(chat_id)

        # If the chat is new, set up the chat document
        chat_doc = chat_ref.get()
        if not chat_doc.exists:
            chat_data = {
                "chat_id": chat_id,
                "user_ids": [user_id] if user_id else [],
                "session_ids": [session_id] if not user_id else [],
                "created_at": firestore.SERVER_TIMESTAMP,
                "last_updated": firestore.SERVER_TIMESTAMP,
                "name": f"Chat {firestore.SERVER_TIMESTAMP}",  # Default name
            }
            chat_ref.set(chat_data)
            logger.debug(f"New chat document created with chat_id: {chat_id}")
        else:
            chat_data = chat_doc.to_dict()
            if user_id and user_id not in chat_data["user_ids"]:
                chat_ref.update({"user_ids": firestore.ArrayUnion([user_id])})
            if not user_id and session_id not in chat_data["session_ids"]:
                chat_ref.update({"session_ids": firestore.ArrayUnion([session_id])})
            logger.debug(f"Chat document updated with chat_id: {chat_id}")

        session_ref = db.collection("sessions").document(session_id)

        # Check if the session document already exists
        session_doc = session_ref.get()
        if not session_doc.exists:
            session_data = {
                "session_id": session_id,
                "timestamp": firestore.SERVER_TIMESTAMP,
                "user_agent": user_agent,
                "ip_address": client_ip,
                "user_id": user_id if user_id else None,
            }
            session_ref.set(session_data, merge=True)
        elif user_id and user_id != session_doc.to_dict().get("user_id"):
            session_ref.update({"user_id": user_id})

        # Retrieve the conversation context (up to the last 10 messages)
        messages_ref = chat_ref.collection("messages")
        query = messages_ref.order_by(
            "timestamp", direction=firestore.Query.DESCENDING
        ).limit(10)
        messages = query.stream()
        context = [msg.to_dict() for msg in messages][::-1]

        new_message = {
            "message_id": os.urandom(16).hex(),
            "user_id": user_id if user_id else None,
            "session_id": session_id,
            "role": "user",
            "content": request.message,
            "timestamp": firestore.SERVER_TIMESTAMP,
        }
        context.append(new_message)

        if len(context) > 10:
            context = summarize_context(context)
        else:
            context = context[-10:]

        # Convert context to ChatMessage objects
        chat_history = [
            ChatMessage(role=msg["role"], content=msg["content"]) for msg in context
        ]

        # Define voice types
        voice_prompts = {
            "normal": "You are an AI-powered chatbot specialized in assisting cannabis marketers. Your name is BakedBot.",
            "pops": "You are a fatherly and upbeat AI assistant, ready to help with cannabis marketing. But you sound like Pops from the movie Friday, use his style of talk.",
            "smokey": "You are a laid-back and cool AI assistant, providing cannabis marketing insights. But sounds like Smokey from the movie Friday, use his style of talk.",
        }
        voice_prompt = voice_prompts.get(request.voice_type, voice_prompts["normal"])

        # Create the prompt to send to the AI agent
        new_prompt = f"{voice_prompt} Instructions: {request.message}. Always OUTPUT in markdown."
        agent_response = agent.chat(message=new_prompt, chat_history=chat_history)

        response_text = (
            agent_response.response if agent_response else "No response available."
        )

        # Save the assistant's response in the chat history
        assistant_message = {
            "message_id": os.urandom(16).hex(),
            "user_id": None,
            "session_id": session_id,
            "role": "assistant",
            "content": response_text,
            "timestamp": firestore.SERVER_TIMESTAMP,
        }

        # Also store the new user message in the messages collection
        messages_ref.document(new_message["message_id"]).set(new_message)
        messages_ref.document(assistant_message["message_id"]).set(assistant_message)

        # Update the last_updated timestamp on the chat document
        chat_ref.update({"last_updated": firestore.SERVER_TIMESTAMP})

        # Schedule the cleanup task for old sessions
        background_tasks.add_task(clean_up_old_sessions)

        # Return the chat response along with the chat_id
        return ChatResponse(response=response_text, chat_id=chat_id)

    except Exception as e:
        logger.error("Error occurred in chat_endpoint: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/user/chats")
async def get_user_chats(
    authorization: str = Header(None),  # Firebase auth token
):
    logger.debug("Fetching all user chats")
    try:
        # Verify user authentication
        if authorization:
            try:
                token = authorization.split(" ")[1]
                decoded_token = verify_firebase_token(token)
                user_id = decoded_token.get("uid")
                logger.debug("User authenticated with user_id: %s", user_id)
            except IndexError:
                raise HTTPException(
                    status_code=400, detail="Invalid authorization header format"
                )
        else:
            raise HTTPException(
                status_code=401, detail="Authorization header missing or invalid"
            )

        # Fetch all chats for the authenticated user
        chats_ref = db.collection("chats").where("user_ids", "array_contains", user_id)
        chats = chats_ref.stream()
        chat_list = [{"chat_id": chat.id, **chat.to_dict()} for chat in chats]

        logger.debug("User chats retrieved for user_id: %s", user_id)
        return {"user_id": user_id, "chats": chat_list}

    except Exception as e:
        logger.error("Error occurred while fetching user chats: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/chat/messages")
async def get_chat_messages(
    chat_id: str = Query(..., description="The chat ID to fetch messages for"),
    authorization: str = Header(None),  # Firebase auth token
):
    logger.debug("Fetching chat messages for chat_id: %s", chat_id)
    try:
        # Verify user authentication
        if authorization:
            try:
                token = authorization.split(" ")[1]
                decoded_token = verify_firebase_token(token)
                user_id = decoded_token.get("uid")
                logger.debug("User authenticated with user_id: %s", user_id)
            except IndexError:
                raise HTTPException(
                    status_code=400, detail="Invalid authorization header format"
                )
        else:
            raise HTTPException(
                status_code=401, detail="Authorization header missing or invalid"
            )

        # Reference the chat document in the chats collection
        chat_ref = db.collection("chats").document(chat_id)
        chat_doc = chat_ref.get()
        if not chat_doc.exists:
            raise HTTPException(status_code=404, detail="Chat not found")

        # Retrieve messages from the chat
        messages_ref = chat_ref.collection("messages")
        messages = messages_ref.order_by("timestamp").stream()
        chat_history = [msg.to_dict() for msg in messages]

        logger.debug("Chat messages retrieved for chat_id: %s", chat_id)
        return {"chat_id": chat_id, "messages": chat_history}

    except Exception as e:
        logger.error("Error occurred while fetching chat messages: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.put("/chat/rename")
async def rename_chat(
    chat_id: str = Query(..., description="The chat ID to rename"),
    new_name: str | None = Query(None, description="The new name for the chat"),
    authorization: str = Header(None),  # Firebase auth token
):
    logger.debug("Renaming chat for chat_id: %s", chat_id)
    try:
        # Verify user authentication
        if authorization:
            try:
                token = authorization.split(" ")[1]
                decoded_token = verify_firebase_token(token)
                user_id = decoded_token.get("uid")
                logger.debug("User authenticated with user_id: %s", user_id)
            except IndexError:
                raise HTTPException(
                    status_code=400, detail="Invalid authorization header format"
                )
        else:
            raise HTTPException(
                status_code=401, detail="Authorization header missing or invalid"
            )

        # Reference the chat document in the chats collection
        chat_ref = db.collection("chats").document(chat_id)
        chat_doc = chat_ref.get()
        if not chat_doc.exists:
            raise HTTPException(status_code=404, detail="Chat not found")

        # If no new_name is provided, generate a title using the LLM
        if not new_name:
            messages_ref = chat_ref.collection("messages")
            messages = messages_ref.order_by("timestamp").stream()
            chat_history = [msg.to_dict() for msg in messages]

            # Generate a short title using the utility function
            full_content = " ".join(
                [f"{msg['role']}: {msg['content']}" for msg in chat_history]
            )
            new_name = generate_default_chat_name(full_content)
            logger.debug(
                "Generated new chat title: %s for chat_id: %s", new_name, chat_id
            )

        # Update the chat name in Firestore
        chat_ref.update({"name": new_name})
        logger.debug("Chat renamed to: %s for chat_id: %s", new_name, chat_id)
        return {"chat_id": chat_id, "new_name": new_name}

    except Exception as e:
        logger.error("Error occurred while renaming chat: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/logout")
async def logout_endpoint(
    fastapi_request: Request,
    background_tasks: BackgroundTasks,
    authorization: str = Header(None),
):
    try:
        session_id = fastapi_request.session.get("session_id")
        if not session_id:
            raise HTTPException(status_code=400, detail="Session ID not found")

        if authorization:
            try:
                token = authorization.split(" ")[1]
                decoded_token = verify_firebase_token(token)
                user_id = decoded_token.get("uid")

                # Revoke Firebase token
                auth.revoke_refresh_tokens(user_id)
                logger.debug(f"Revoked Firebase token for user_id: {user_id}")

                # End session and calculate session length
                end_session(session_id)

                # Optionally clear the session from the request
                fastapi_request.session.clear()
                logger.debug(f"Session {session_id} ended and cleared.")

                # Schedule the cleanup task for old sessions
                background_tasks.add_task(clean_up_old_sessions)

                return {"detail": "Logged out and session ended successfully."}
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))

        else:
            raise HTTPException(
                status_code=400, detail="Authorization header missing or invalid"
            )

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.put("/chat/{chat_id}/archive")
async def archive_chat(
    chat_id: str = Path(..., description="The chat ID to archive"),
    authorization: str = Header(None),  # Firebase auth token
):
    logger.debug(f"Archiving chat with chat_id: {chat_id}")
    try:
        # Verify user authentication
        if authorization:
            token = authorization.split(" ")[1]
            decoded_token = verify_firebase_token(token)
            user_id = decoded_token.get("uid")
            logger.debug(f"User authenticated with user_id: {user_id}")
        else:
            raise HTTPException(
                status_code=401, detail="Authorization header missing or invalid"
            )

        # Reference the chat document in the chats collection
        chat_ref = db.collection("chats").document(chat_id)
        chat_doc = chat_ref.get()
        if not chat_doc.exists:
            raise HTTPException(status_code=404, detail="Chat not found")

        # Check if the user has permission to archive this chat
        chat_data = chat_doc.to_dict()
        if user_id not in chat_data.get("user_ids", []):
            raise HTTPException(
                status_code=403,
                detail="User does not have permission to archive this chat",
            )

        # Update the chat document to mark it as archived
        chat_ref.update(
            {
                "archived": True,
                "archived_at": firestore.SERVER_TIMESTAMP,
                "archived_by": user_id,
            }
        )

        logger.debug(f"Chat archived successfully for chat_id: {chat_id}")
        return {"chat_id": chat_id, "status": "archived"}

    except Exception as e:
        logger.error(f"Error occurred while archiving chat: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/chat/{chat_id}")
async def delete_chat(
    chat_id: str = Path(..., description="The chat ID to delete"),
    authorization: str = Header(None),  # Firebase auth token
):
    logger.debug(f"Deleting chat with chat_id: {chat_id}")
    try:
        # Verify user authentication
        if authorization:
            token = authorization.split(" ")[1]
            decoded_token = verify_firebase_token(token)
            user_id = decoded_token.get("uid")
            logger.debug(f"User authenticated with user_id: {user_id}")
        else:
            raise HTTPException(
                status_code=401, detail="Authorization header missing or invalid"
            )

        # Reference the chat document in the chats collection
        chat_ref = db.collection("chats").document(chat_id)
        chat_doc = chat_ref.get()
        if not chat_doc.exists:
            raise HTTPException(status_code=404, detail="Chat not found")

        # Check if the user has permission to delete this chat
        chat_data = chat_doc.to_dict()
        if user_id not in chat_data.get("user_ids", []):
            raise HTTPException(
                status_code=403,
                detail="User does not have permission to delete this chat",
            )

        # Delete all messages in the chat
        messages_ref = chat_ref.collection("messages")
        batch = db.batch()
        messages = messages_ref.stream()
        for message in messages:
            batch.delete(message.reference)

        # Delete the chat document
        batch.delete(chat_ref)

        # Commit the batch delete operation
        batch.commit()

        logger.debug(
            f"Chat and its messages deleted successfully for chat_id: {chat_id}"
        )
        return {"chat_id": chat_id, "status": "deleted"}

    except Exception as e:
        logger.error(f"Error occurred while deleting chat: {e}")
        raise HTTPException(status_code=500, detail=str(e))


def verify_firebase_token(token: str) -> dict:
    # Implement token verification using Firebase Admin SDK
    try:
        decoded_token = auth.verify_id_token(token)
        return decoded_token
    except Exception as e:
        logger.error(f"Failed to verify token: {e}")
        raise HTTPException(status_code=401, detail="Invalid Firebase token")


def authenticate_user(authorization: str) -> str:
    if not authorization:
        raise HTTPException(
            status_code=401, detail="Authorization header missing or invalid"
        )
    try:
        token = authorization.split(" ")[1]
        decoded_token = verify_firebase_token(token)
        user_id = decoded_token.get("uid")
        logger.debug(f"User authenticated with user_id: {user_id}")
        return user_id
    except IndexError:
        raise HTTPException(
            status_code=400, detail="Invalid authorization header format"
        )
    except Exception as auth_error:
        raise HTTPException(
            status_code=401, detail=f"Authentication failed: {str(auth_error)}"
        )


@app.get("/live_products")
async def get_live_products(
    authorization: str = Header(None),  # Firebase auth token
    lat: Optional[float] = Query(None, description="Latitude"),
    lng: Optional[float] = Query(None, description="Longitude"),
    distance: Optional[float] = Query(None, description="Miles"),
    states: List[str] = Query(..., description="List of states, at least one required"),
    retailers: Optional[List[int]] = Query(None, description="List of retailer IDs"),
    brands: Optional[List[int]] = Query(None, description="List of brand IDs"),
    page: int = Query(1, ge=1, description="Page number, starting from 1"),
    skus: Optional[List[str]] = Query(None, description="Cann SKU IDs"),
    brand_name: Optional[str] = Query(None, description="Brand Name"),
    product_name: Optional[str] = Query(None, description="Product Name"),
    display_weight: Optional[str] = Query(None, description="Display Weight"),
    category: Optional[str] = Query(None, description="Category"),
    subcategory: Optional[str] = Query(None, description="Subcategory"),
    tags: Optional[List[str]] = Query(None, description="Product Tags"),
    percentage_thc: Optional[float] = Query(None, description="Percentage THC"),
    percentage_cbd: Optional[float] = Query(None, description="Percentage CBD"),
    mg_thc: Optional[float] = Query(None, description="Mg THC"),
    mg_cbd: Optional[float] = Query(None, description="Mg CBD"),
    quantity_per_package: Optional[int] = Query(
        None, description="Quantity Per Package"
    ),
    medical: Optional[bool] = Query(None, description="Medical"),
    recreational: Optional[bool] = Query(None, description="Recreational"),
    latest_price: Optional[float] = Query(None, description="Latest Price"),
    menu_provider: Optional[str] = Query(None, description="Menu Provider"),
):
    # Authenticate user
    user_id = authenticate_user(authorization)

    # Construct the query parameters
    params = {
        "lat": lat,
        "lng": lng,
        "distance": distance,
        "states": states,
        "retailers": retailers,
        "brands": brands,
        "page": page,
        "skus": skus,
        "brand_name": brand_name,
        "product_name": product_name,
        "display_weight": display_weight,
        "category": category,
        "subcategory": subcategory,
        "tags": tags,
        "percentage_thc": percentage_thc,
        "percentage_cbd": percentage_cbd,
        "mg_thc": mg_thc,
        "mg_cbd": mg_cbd,
        "quantity_per_package": quantity_per_package,
        "medical": medical,
        "recreational": recreational,
        "latest_price": latest_price,
        "menu_provider": menu_provider,
    }

    # Remove None values from params
    params = {k: v for k, v in params.items() if v is not None}

    # Make the API call
    async with httpx.AsyncClient() as client:
        try:
            headers = {
                "Authorization": f"Bearer {os.getenv('CANNMENUS_API_KEY')}",
                "Content-Type": "application/json",
            }
            response = await client.get(
                "https://api.cannmenus.com/v1/products", params=params, headers=headers
            )
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            raise HTTPException(status_code=e.response.status_code, detail=str(e))
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))


@app.post("/scrape-retailer-products/{retailer_id}")
async def scrape_retailer_products(
    background_tasks: BackgroundTasks,
    retailer_id: int = Path(..., description="The ID of the retailer to scrape"),
    authorization: Optional[str] = Header(None, description="Firebase auth token"),
):
    logger.info(f"Starting product scrape for retailer_id: {retailer_id}")
    try:
        # Authenticate user
        user_id = authenticate_user(authorization)
        logger.info(f"User authenticated with user_id: {user_id}")

        # Start the scraping process in the background
        background_tasks.add_task(scrape_and_store_products, retailer_id, user_id)

        return {
            "message": "Product scraping started",
            "retailer_id": retailer_id,
            "user_id": user_id,
        }

    except HTTPException as http_error:
        logger.error(f"HTTP error occurred: {http_error}")
        raise http_error
    except Exception as e:
        logger.error(f"Error occurred while initiating product scrape: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}",
        )


def scrape_and_store_products(retailer_id: int, user_id: str):
    logger.info(f"Scraping products for retailer_id: {retailer_id}")
    try:
        # Initialize variables for pagination
        page = 1
        all_products = []
        total_pages = 1
        requests_count = 0
        start_time = time.time()

        headers = {
            "X-Token": f"{os.getenv('CANNMENUS_API_KEY')}",
        }
        while page <= total_pages:
            # Implement rate limiting
            if requests_count >= 10:  # Limit to 10 requests per minute
                elapsed_time = time.time() - start_time
                if elapsed_time < 60:
                    sleep_time = 60 - elapsed_time
                    logger.info(
                        f"Rate limit reached. Sleeping for {sleep_time:.2f} seconds"
                    )
                    time.sleep(sleep_time)
                requests_count = 0
                start_time = time.time()

            params = {"retailers": [retailer_id], "page": page, "states": "michigan"}
            try:
                with httpx.Client() as client:
                    response = client.get(
                        "https://api.cannmenus.com/v1/products",
                        params=params,
                        headers=headers,
                        timeout=10.0,
                    )
                response.raise_for_status()
                data = response.json()

                requests_count += 1

                products = data.get("data", [])
                if not products:
                    break  # No more products to fetch

                # Flatten and process the products
                for product_group in products:
                    sku = product_group.get("sku")
                    for product in product_group.get("products", []):
                        flattened_product = {
                            "retailer_id": retailer_id,
                            "sku": sku,
                            **product,
                        }
                        all_products.append(flattened_product)

                total_pages = data.get("pagination", {}).get("total_pages", total_pages)
                logger.info(
                    f"Fetched page {page} of {total_pages} for retailer {retailer_id}"
                )
                page += 1

                # Add a small delay between requests
                time.sleep(1)

            except httpx.HTTPStatusError as e:
                logger.error(
                    f"HTTP error occurred: {e.response.status_code} - {e.response.text}"
                )
                break
            except httpx.RequestError as e:
                logger.error(f"An error occurred while requesting: {e}")
                break

        # Process and store the products in Firestore
        products_ref = db.collection("products")

        # Update products
        batch = db.batch()
        updated_product_ids = set()
        count = 0
        for product in all_products:
            product_id = product.get("sku")
            if not product_id:
                logger.warning(f"Skipping product without SKU: {product}")
                continue
            product_ref = products_ref.document(product_id)
            batch.set(
                product_ref,
                {
                    **product,
                    "last_updated": firestore.SERVER_TIMESTAMP,
                },
                merge=True,
            )
            updated_product_ids.add(product_id)
            count += 1

            # If we've reached the batch limit, commit and reset
            if count % 500 == 0:
                batch.commit()
                batch = db.batch()

        # Commit any remaining updates
        if count % 500 != 0:
            batch.commit()

        # Delete products that are no longer associated with this retailer
        query = products_ref.where("retailer_id", "==", retailer_id)
        existing_products = query.stream()

        delete_batch = db.batch()
        delete_count = 0
        for doc in existing_products:
            if doc.id not in updated_product_ids:
                delete_batch.delete(doc.reference)
                delete_count += 1

            # If we've reached the batch limit, commit and reset
            if delete_count % 500 == 0:
                delete_batch.commit()
                delete_batch = db.batch()

        # Commit any remaining deletes
        if delete_count % 500 != 0:
            delete_batch.commit()

        logger.info(
            f"Successfully scraped and stored {len(updated_product_ids)} products for retailer_id: {retailer_id}"
        )

    except Exception as e:
        logger.error(f"Error occurred while scraping products: {e}")


@app.get("/products")
async def get_products(
    authorization: str = Header(None),  # Firebase auth token
    page: int = Query(1, ge=1, description="Page number, starting from 1"),
    page_size: int = Query(20, ge=1, le=100, description="Number of items per page"),
    states: Optional[List[str]] = Query(None, description="List of states"),
    retailers: Optional[List[int]] = Query(None, description="List of retailer IDs"),
    brands: Optional[List[int]] = Query(None, description="List of brand IDs"),
    skus: Optional[List[str]] = Query(None, description="Cann SKU IDs"),
    brand_name: Optional[str] = Query(None, description="Brand Name"),
    product_name: Optional[str] = Query(None, description="Product Name"),
    category: Optional[str] = Query(None, description="Category"),
    subcategory: Optional[str] = Query(None, description="Subcategory"),
    tags: Optional[List[str]] = Query(None, description="Product Tags"),
    percentage_thc_min: Optional[float] = Query(
        None, description="Minimum Percentage THC"
    ),
    percentage_thc_max: Optional[float] = Query(
        None, description="Maximum Percentage THC"
    ),
    percentage_cbd_min: Optional[float] = Query(
        None, description="Minimum Percentage CBD"
    ),
    percentage_cbd_max: Optional[float] = Query(
        None, description="Maximum Percentage CBD"
    ),
    latest_price_min: Optional[float] = Query(None, description="Minimum Latest Price"),
    latest_price_max: Optional[float] = Query(None, description="Maximum Latest Price"),
    medical: Optional[bool] = Query(None, description="Medical"),
    recreational: Optional[bool] = Query(None, description="Recreational"),
    menu_provider: Optional[str] = Query(None, description="Menu Provider"),
):
    user_id = authenticate_user(authorization)

    try:
        # Initialize query
        products_ref = db.collection("products")
        query = products_ref

        # Keep track of inequality filters to comply with Firestore limitations
        inequality_field = None

        # Apply filters
        # Only one 'in' filter is allowed in Firestore
        if retailers:
            if len(retailers) > 10:
                raise HTTPException(
                    status_code=400, detail="Maximum of 10 retailers allowed"
                )
            query = query.where("retailer_id", "in", retailers)
        elif brands:
            if len(brands) > 10:
                raise HTTPException(
                    status_code=400, detail="Maximum of 10 brands allowed"
                )
            query = query.where("brand_id", "in", brands)
        elif skus:
            if len(skus) > 10:
                raise HTTPException(
                    status_code=400, detail="Maximum of 10 skus allowed"
                )
            query = query.where("sku", "in", skus)

        if brand_name:
            query = query.where("brand_name", "==", brand_name)
        if product_name:
            query = query.where("product_name", "==", product_name)
        if category:
            query = query.where("category", "==", category)
        if subcategory:
            query = query.where("subcategory", "==", subcategory)
        if tags:
            query = query.where("tags", "array_contains_any", tags)
        if medical is not None:
            query = query.where("medical", "==", medical)
        if recreational is not None:
            query = query.where("recreational", "==", recreational)
        if menu_provider:
            query = query.where("menu_provider", "==", menu_provider)
        if states:
            if len(states) > 10:
                raise HTTPException(
                    status_code=400, detail="Maximum of 10 states allowed"
                )
            if len(states) == 1:
                query = query.where("state", "==", states[0])
            else:
                query = query.where("state", "in", states)

        # Handle inequality filters
        if percentage_thc_min is not None or percentage_thc_max is not None:
            if inequality_field and inequality_field != "percentage_thc":
                raise HTTPException(
                    status_code=400,
                    detail="Cannot apply inequality filters on multiple fields",
                )
            inequality_field = "percentage_thc"
            if percentage_thc_min is not None:
                query = query.where("percentage_thc", ">=", percentage_thc_min)
            if percentage_thc_max is not None:
                query = query.where("percentage_thc", "<=", percentage_thc_max)

        if percentage_cbd_min is not None or percentage_cbd_max is not None:
            if inequality_field and inequality_field != "percentage_cbd":
                raise HTTPException(
                    status_code=400,
                    detail="Cannot apply inequality filters on multiple fields",
                )
            inequality_field = "percentage_cbd"
            if percentage_cbd_min is not None:
                query = query.where("percentage_cbd", ">=", percentage_cbd_min)
            if percentage_cbd_max is not None:
                query = query.where("percentage_cbd", "<=", percentage_cbd_max)

        if latest_price_min is not None or latest_price_max is not None:
            if inequality_field and inequality_field != "latest_price":
                raise HTTPException(
                    status_code=400,
                    detail="Cannot apply inequality filters on multiple fields",
                )
            inequality_field = "latest_price"
            if latest_price_min is not None:
                query = query.where("latest_price", ">=", latest_price_min)
            if latest_price_max is not None:
                query = query.where("latest_price", "<=", latest_price_max)

        # Apply ordering if inequality filters are used
        if inequality_field:
            query = query.order_by(inequality_field)

        # Calculate offset
        offset = (page - 1) * page_size

        # Execute query with pagination
        docs = query.offset(offset).limit(page_size).stream()

        products = [doc.to_dict() for doc in docs]

        return {
            "data": products,
            "meta": {
                "current_page": page,
                "per_page": page_size,
                "total_items": len(
                    products
                ),  # Total count is approximate due to Firestore limitations
            },
        }

    except HTTPException as e:
        logger.error(f"HTTPException occurred: {e.detail}")
        raise e
    except Exception as e:
        logger.error(f"Error occurred while fetching products: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Run the FastAPI app with Uvicorn for performance
if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
